<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <!-- For Mobile Devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Type" content="text/xhtml; charset=utf-8">
  <meta name="generator" content="Doxygen 1.8.13">
  <title>SPDK: bdev.h File Reference</title>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,900" type="text/css">
  <link href="../css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="tabs.css" type="text/css">
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div class="container-fluid">
  <div id="top">  <!-- do not remove this div, it is closed by doxygen! -->
    <div class="row no-gutters">
      <div class="col-sm-12">
        <section id="nav">
          <div class="navbar navbar-default navbar-static-top banner-tabs">
            <ul class="nav navbar-nav">
              <li role="presentation">
                <a href="http://www.spdk.io/">
                  <i class="glyphicon glyphicon-home"></i>
                  <span class="box-name">home</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/releases/">
                  <i class="glyphicon glyphicon-download-alt"></i>
                  <span class="box-name">download</span>
                </a>
              </li>
              <li class="active" role="presentation">
                <a href="index.html">
                  <i class="glyphicon glyphicon-book"></i>
                  <span class="box-name">documentation</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/development/">
                  <i class="glyphicon glyphicon-wrench"></i>
                  <span class="box-name">development</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/community/">
                  <i class="glyphicon glyphicon-envelope"></i>
                  <span class="box-name">community</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/blog/">
                  <i class="glyphicon glyphicon-comment"></i>
                  <span class="box-name">Blog</span>
                </a>
              </li>
              <li role="presentation">
                <a href="https://github.com/spdk/spdk/wiki/Roadmap">
                  <i class="glyphicon glyphicon-map-marker"></i>
                  <span class="box-name">Roadmap</span>
                </a>
              </li>
            </ul>
          </div>
        </section>
      </div>
    </div>
<!-- Generated by Doxygen 1.8.13 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_67fbcc0b4317645100def1406b508c33.html">spdk</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">bdev.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Block device abstraction layer.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__bdev__io__stat.html">spdk_bdev_io_stat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a22219ae3fb084dcb87bcc6d454b415aa"><td class="memItemLeft" align="right" valign="top"><a id="a22219ae3fb084dcb87bcc6d454b415aa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_BDEV_SMALL_BUF_MAX_SIZE</b>&#160;&#160;&#160;8192</td></tr>
<tr class="separator:a22219ae3fb084dcb87bcc6d454b415aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9496c34e0fc135e1f309fd586e8e65d0"><td class="memItemLeft" align="right" valign="top"><a id="a9496c34e0fc135e1f309fd586e8e65d0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_BDEV_LARGE_BUF_MAX_SIZE</b>&#160;&#160;&#160;(64 * 1024)</td></tr>
<tr class="separator:a9496c34e0fc135e1f309fd586e8e65d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a51a55c97586c2d524fffcabc4d7910d6"><td class="memItemLeft" align="right" valign="top"><a id="a51a55c97586c2d524fffcabc4d7910d6"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_bdev_remove_cb_t</b>) (void *remove_ctx)</td></tr>
<tr class="separator:a51a55c97586c2d524fffcabc4d7910d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5602dfd313f90032dd91683b9663e3"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>) (struct spdk_bdev_io *bdev_io, bool success, void *cb_arg)</td></tr>
<tr class="memdesc:a0c5602dfd313f90032dd91683b9663e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block device completion callback.  <a href="#a0c5602dfd313f90032dd91683b9663e3">More...</a><br /></td></tr>
<tr class="separator:a0c5602dfd313f90032dd91683b9663e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ad6c166f5d928c2995df57c96a2977862"><td class="memItemLeft" align="right" valign="top"><a id="ad6c166f5d928c2995df57c96a2977862"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#ad6c166f5d928c2995df57c96a2977862">spdk_bdev_status</a> { <b>SPDK_BDEV_STATUS_INVALID</b>, 
<b>SPDK_BDEV_STATUS_UNCLAIMED</b>, 
<b>SPDK_BDEV_STATUS_CLAIMED</b>, 
<b>SPDK_BDEV_STATUS_REMOVING</b>
 }<tr class="memdesc:ad6c166f5d928c2995df57c96a2977862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blockdev status. <br /></td></tr>
</td></tr>
<tr class="separator:ad6c166f5d928c2995df57c96a2977862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633029e24ab5ae4a689bffa2565a519f"><td class="memItemLeft" align="right" valign="top"><a id="a633029e24ab5ae4a689bffa2565a519f"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a633029e24ab5ae4a689bffa2565a519f">spdk_bdev_io_type</a> { <br />
&#160;&#160;<b>SPDK_BDEV_IO_TYPE_READ</b> = 1, 
<b>SPDK_BDEV_IO_TYPE_WRITE</b>, 
<b>SPDK_BDEV_IO_TYPE_UNMAP</b>, 
<b>SPDK_BDEV_IO_TYPE_FLUSH</b>, 
<br />
&#160;&#160;<b>SPDK_BDEV_IO_TYPE_RESET</b>, 
<b>SPDK_BDEV_IO_TYPE_NVME_ADMIN</b>, 
<b>SPDK_BDEV_IO_TYPE_NVME_IO</b>
<br />
 }<tr class="memdesc:a633029e24ab5ae4a689bffa2565a519f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blockdev I/O type. <br /></td></tr>
</td></tr>
<tr class="separator:a633029e24ab5ae4a689bffa2565a519f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afdd0a0fca295d32b20bd76da384c1a71"><td class="memItemLeft" align="right" valign="top"><a id="afdd0a0fca295d32b20bd76da384c1a71"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_bdev_initialize</b> (void)</td></tr>
<tr class="separator:afdd0a0fca295d32b20bd76da384c1a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9475b84efdaeb962f5a8cb4f6f6c3d42"><td class="memItemLeft" align="right" valign="top"><a id="a9475b84efdaeb962f5a8cb4f6f6c3d42"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_bdev_finish</b> (void)</td></tr>
<tr class="separator:a9475b84efdaeb962f5a8cb4f6f6c3d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273c20b5f07dd8c727ec0d0b80b804fe"><td class="memItemLeft" align="right" valign="top"><a id="a273c20b5f07dd8c727ec0d0b80b804fe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_bdev_config_text</b> (FILE *fp)</td></tr>
<tr class="separator:a273c20b5f07dd8c727ec0d0b80b804fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c759c53d028e3e408d19156f0e1eb1"><td class="memItemLeft" align="right" valign="top"><a id="a89c759c53d028e3e408d19156f0e1eb1"></a>
struct spdk_bdev *&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_bdev_get_by_name</b> (const char *bdev_name)</td></tr>
<tr class="separator:a89c759c53d028e3e408d19156f0e1eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578b0a9d444ddbb23c8181d9a5ea4f46"><td class="memItemLeft" align="right" valign="top"><a id="a578b0a9d444ddbb23c8181d9a5ea4f46"></a>
struct spdk_bdev *&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_bdev_first</b> (void)</td></tr>
<tr class="separator:a578b0a9d444ddbb23c8181d9a5ea4f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c0b9cb8dde1177df3442206cf87d2d"><td class="memItemLeft" align="right" valign="top"><a id="aa1c0b9cb8dde1177df3442206cf87d2d"></a>
struct spdk_bdev *&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_bdev_next</b> (struct spdk_bdev *prev)</td></tr>
<tr class="separator:aa1c0b9cb8dde1177df3442206cf87d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5600670a9cb061bb5bd9ed4d8dd7046"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#af5600670a9cb061bb5bd9ed4d8dd7046">spdk_bdev_claim</a> (struct spdk_bdev *bdev, spdk_bdev_remove_cb_t remove_cb, void *remove_ctx)</td></tr>
<tr class="memdesc:af5600670a9cb061bb5bd9ed4d8dd7046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Claim ownership of a block device.  <a href="#af5600670a9cb061bb5bd9ed4d8dd7046">More...</a><br /></td></tr>
<tr class="separator:af5600670a9cb061bb5bd9ed4d8dd7046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae080366bf0d3b59d0bb05f2b3e698dea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#ae080366bf0d3b59d0bb05f2b3e698dea">spdk_bdev_unclaim</a> (struct spdk_bdev *bdev)</td></tr>
<tr class="memdesc:ae080366bf0d3b59d0bb05f2b3e698dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release claim of ownership of a block device.  <a href="#ae080366bf0d3b59d0bb05f2b3e698dea">More...</a><br /></td></tr>
<tr class="separator:ae080366bf0d3b59d0bb05f2b3e698dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd5dff692dc162459801d5649fe7655"><td class="memItemLeft" align="right" valign="top"><a id="a7cd5dff692dc162459801d5649fe7655"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_bdev_io_type_supported</b> (struct spdk_bdev *bdev, enum <a class="el" href="bdev_8h.html#a633029e24ab5ae4a689bffa2565a519f">spdk_bdev_io_type</a> io_type)</td></tr>
<tr class="separator:a7cd5dff692dc162459801d5649fe7655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d158f886b7ae2f735a794da420ca55"><td class="memItemLeft" align="right" valign="top"><a id="a84d158f886b7ae2f735a794da420ca55"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_bdev_dump_config_json</b> (struct spdk_bdev *bdev, struct spdk_json_write_ctx *w)</td></tr>
<tr class="separator:a84d158f886b7ae2f735a794da420ca55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97a853dcb945bf004817424b7aa28af"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#ad97a853dcb945bf004817424b7aa28af">spdk_bdev_get_name</a> (const struct spdk_bdev *bdev)</td></tr>
<tr class="memdesc:ad97a853dcb945bf004817424b7aa28af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get block device name.  <a href="#ad97a853dcb945bf004817424b7aa28af">More...</a><br /></td></tr>
<tr class="separator:ad97a853dcb945bf004817424b7aa28af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb4d1f8822c30be8c5d9c5dc3e62483"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a1cb4d1f8822c30be8c5d9c5dc3e62483">spdk_bdev_get_product_name</a> (const struct spdk_bdev *bdev)</td></tr>
<tr class="memdesc:a1cb4d1f8822c30be8c5d9c5dc3e62483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get block device product name.  <a href="#a1cb4d1f8822c30be8c5d9c5dc3e62483">More...</a><br /></td></tr>
<tr class="separator:a1cb4d1f8822c30be8c5d9c5dc3e62483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba8c5672c8226b9b63f44543518c527"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a3ba8c5672c8226b9b63f44543518c527">spdk_bdev_get_block_size</a> (const struct spdk_bdev *bdev)</td></tr>
<tr class="memdesc:a3ba8c5672c8226b9b63f44543518c527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get block device logical block size.  <a href="#a3ba8c5672c8226b9b63f44543518c527">More...</a><br /></td></tr>
<tr class="separator:a3ba8c5672c8226b9b63f44543518c527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86568eca8f0b4d0dc9bc59c5138fc7a5"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a86568eca8f0b4d0dc9bc59c5138fc7a5">spdk_bdev_get_num_blocks</a> (const struct spdk_bdev *bdev)</td></tr>
<tr class="memdesc:a86568eca8f0b4d0dc9bc59c5138fc7a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get size of block device in logical blocks.  <a href="#a86568eca8f0b4d0dc9bc59c5138fc7a5">More...</a><br /></td></tr>
<tr class="separator:a86568eca8f0b4d0dc9bc59c5138fc7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055368a3ce95cb597c99e9920dd025a4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a055368a3ce95cb597c99e9920dd025a4">spdk_bdev_get_max_unmap_descriptors</a> (const struct spdk_bdev *bdev)</td></tr>
<tr class="memdesc:a055368a3ce95cb597c99e9920dd025a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum number of descriptors per unmap request.  <a href="#a055368a3ce95cb597c99e9920dd025a4">More...</a><br /></td></tr>
<tr class="separator:a055368a3ce95cb597c99e9920dd025a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d238484b372a77ba130fbb70f83519"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#ab4d238484b372a77ba130fbb70f83519">spdk_bdev_get_buf_align</a> (const struct spdk_bdev *bdev)</td></tr>
<tr class="memdesc:ab4d238484b372a77ba130fbb70f83519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get minimum I/O buffer address alignment for a bdev.  <a href="#ab4d238484b372a77ba130fbb70f83519">More...</a><br /></td></tr>
<tr class="separator:ab4d238484b372a77ba130fbb70f83519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f6d6ce09da384501f09a49581caa37"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a93f6d6ce09da384501f09a49581caa37">spdk_bdev_has_write_cache</a> (const struct spdk_bdev *bdev)</td></tr>
<tr class="memdesc:a93f6d6ce09da384501f09a49581caa37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether block device has an enabled write cache.  <a href="#a93f6d6ce09da384501f09a49581caa37">More...</a><br /></td></tr>
<tr class="separator:a93f6d6ce09da384501f09a49581caa37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4015ff9aba44261f3b36cde064963a"><td class="memItemLeft" align="right" valign="top">struct spdk_io_channel *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a1b4015ff9aba44261f3b36cde064963a">spdk_bdev_get_io_channel</a> (struct spdk_bdev *bdev)</td></tr>
<tr class="memdesc:a1b4015ff9aba44261f3b36cde064963a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain an I/O channel for this block device.  <a href="#a1b4015ff9aba44261f3b36cde064963a">More...</a><br /></td></tr>
<tr class="separator:a1b4015ff9aba44261f3b36cde064963a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17931abec6a7169432d56b3b72ce604f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a17931abec6a7169432d56b3b72ce604f">spdk_bdev_read</a> (struct spdk_bdev *bdev, struct spdk_io_channel *ch, void *buf, uint64_t offset, uint64_t nbytes, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:a17931abec6a7169432d56b3b72ce604f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a read request to the bdev on the given channel.  <a href="#a17931abec6a7169432d56b3b72ce604f">More...</a><br /></td></tr>
<tr class="separator:a17931abec6a7169432d56b3b72ce604f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39cf118897336906dfd286b3c91295ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a39cf118897336906dfd286b3c91295ce">spdk_bdev_readv</a> (struct spdk_bdev *bdev, struct spdk_io_channel *ch, struct iovec *iov, int iovcnt, uint64_t offset, uint64_t nbytes, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:a39cf118897336906dfd286b3c91295ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a read request to the bdev on the given channel.  <a href="#a39cf118897336906dfd286b3c91295ce">More...</a><br /></td></tr>
<tr class="separator:a39cf118897336906dfd286b3c91295ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd2e65f126665954c23eff4477d4557"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a9dd2e65f126665954c23eff4477d4557">spdk_bdev_write</a> (struct spdk_bdev *bdev, struct spdk_io_channel *ch, void *buf, uint64_t offset, uint64_t nbytes, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:a9dd2e65f126665954c23eff4477d4557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a write request to the bdev on the given channel.  <a href="#a9dd2e65f126665954c23eff4477d4557">More...</a><br /></td></tr>
<tr class="separator:a9dd2e65f126665954c23eff4477d4557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f12f278859dc4e0c6cdec33f9dcb24"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a22f12f278859dc4e0c6cdec33f9dcb24">spdk_bdev_writev</a> (struct spdk_bdev *bdev, struct spdk_io_channel *ch, struct iovec *iov, int iovcnt, uint64_t offset, uint64_t len, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:a22f12f278859dc4e0c6cdec33f9dcb24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a write request to the bdev on the given channel.  <a href="#a22f12f278859dc4e0c6cdec33f9dcb24">More...</a><br /></td></tr>
<tr class="separator:a22f12f278859dc4e0c6cdec33f9dcb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae20739bcbd84bde357e89d96b5e5e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a1ae20739bcbd84bde357e89d96b5e5e7">spdk_bdev_unmap</a> (struct spdk_bdev *bdev, struct spdk_io_channel *ch, struct <a class="el" href="structspdk__scsi__unmap__bdesc.html">spdk_scsi_unmap_bdesc</a> *unmap_d, uint16_t bdesc_count, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:a1ae20739bcbd84bde357e89d96b5e5e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit an unmap request to the block device.  <a href="#a1ae20739bcbd84bde357e89d96b5e5e7">More...</a><br /></td></tr>
<tr class="separator:a1ae20739bcbd84bde357e89d96b5e5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79093fc354725f29207cd9038ac4144a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a79093fc354725f29207cd9038ac4144a">spdk_bdev_flush</a> (struct spdk_bdev *bdev, struct spdk_io_channel *ch, uint64_t offset, uint64_t length, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:a79093fc354725f29207cd9038ac4144a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a flush request to the bdev on the given channel.  <a href="#a79093fc354725f29207cd9038ac4144a">More...</a><br /></td></tr>
<tr class="separator:a79093fc354725f29207cd9038ac4144a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b7c843568980d0f2e2245ee296ee4a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a08b7c843568980d0f2e2245ee296ee4a">spdk_bdev_reset</a> (struct spdk_bdev *bdev, struct spdk_io_channel *ch, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:a08b7c843568980d0f2e2245ee296ee4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a reset request to the bdev on the given channel.  <a href="#a08b7c843568980d0f2e2245ee296ee4a">More...</a><br /></td></tr>
<tr class="separator:a08b7c843568980d0f2e2245ee296ee4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ff477709a4931e98b10c2f39d2d9fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#af0ff477709a4931e98b10c2f39d2d9fc">spdk_bdev_nvme_admin_passthru</a> (struct spdk_bdev *bdev, struct spdk_io_channel *ch, const struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *cmd, void *buf, size_t nbytes, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:af0ff477709a4931e98b10c2f39d2d9fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit an NVMe Admin command to the bdev.  <a href="#af0ff477709a4931e98b10c2f39d2d9fc">More...</a><br /></td></tr>
<tr class="separator:af0ff477709a4931e98b10c2f39d2d9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6073d0f21b837b1afc22859c1d067d77"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a6073d0f21b837b1afc22859c1d067d77">spdk_bdev_nvme_io_passthru</a> (struct spdk_bdev *bdev, struct spdk_io_channel *ch, const struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *cmd, void *buf, size_t nbytes, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:a6073d0f21b837b1afc22859c1d067d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit an NVMe I/O command to the bdev.  <a href="#a6073d0f21b837b1afc22859c1d067d77">More...</a><br /></td></tr>
<tr class="separator:a6073d0f21b837b1afc22859c1d067d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536a365e14bc4f3ddf76b9340958ebd8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a536a365e14bc4f3ddf76b9340958ebd8">spdk_bdev_free_io</a> (struct spdk_bdev_io *bdev_io)</td></tr>
<tr class="memdesc:a536a365e14bc4f3ddf76b9340958ebd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an I/O request.  <a href="#a536a365e14bc4f3ddf76b9340958ebd8">More...</a><br /></td></tr>
<tr class="separator:a536a365e14bc4f3ddf76b9340958ebd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ba28ba382edd1d792d51a054eb3aa2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#ab1ba28ba382edd1d792d51a054eb3aa2">spdk_bdev_get_io_stat</a> (struct spdk_bdev *bdev, struct spdk_io_channel *ch, struct <a class="el" href="structspdk__bdev__io__stat.html">spdk_bdev_io_stat</a> *stat)</td></tr>
<tr class="memdesc:ab1ba28ba382edd1d792d51a054eb3aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return I/O statistics for this channel.  <a href="#ab1ba28ba382edd1d792d51a054eb3aa2">More...</a><br /></td></tr>
<tr class="separator:ab1ba28ba382edd1d792d51a054eb3aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe43254747db3cd072dfb596be3bbf2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#afe43254747db3cd072dfb596be3bbf2f">spdk_bdev_io_get_nvme_status</a> (const struct spdk_bdev_io *bdev_io, int *sct, int *sc)</td></tr>
<tr class="memdesc:afe43254747db3cd072dfb596be3bbf2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the status of bdev_io as an NVMe status code.  <a href="#afe43254747db3cd072dfb596be3bbf2f">More...</a><br /></td></tr>
<tr class="separator:afe43254747db3cd072dfb596be3bbf2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c213b4317d5077197950253af1ac50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#ac3c213b4317d5077197950253af1ac50">spdk_bdev_io_get_scsi_status</a> (const struct spdk_bdev_io *bdev_io, int *sc, int *sk, int *asc, int *ascq)</td></tr>
<tr class="memdesc:ac3c213b4317d5077197950253af1ac50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the status of bdev_io as a SCSI status code.  <a href="#ac3c213b4317d5077197950253af1ac50">More...</a><br /></td></tr>
<tr class="separator:ac3c213b4317d5077197950253af1ac50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05d8c0e82bfbcc209af1eb958230ede"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#aa05d8c0e82bfbcc209af1eb958230ede">spdk_bdev_io_get_iovec</a> (struct spdk_bdev_io *bdev_io, struct iovec **iovp, int *iovcntp)</td></tr>
<tr class="memdesc:aa05d8c0e82bfbcc209af1eb958230ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the iovec describing the data buffer of a bdev_io.  <a href="#aa05d8c0e82bfbcc209af1eb958230ede">More...</a><br /></td></tr>
<tr class="separator:aa05d8c0e82bfbcc209af1eb958230ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Block device abstraction layer. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a0c5602dfd313f90032dd91683b9663e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5602dfd313f90032dd91683b9663e3">&#9670;&nbsp;</a></span>spdk_bdev_io_completion_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_bdev_io_completion_cb) (struct spdk_bdev_io *bdev_io, bool success, void *cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block device completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev_io</td><td>Block device I/O that has completed. </td></tr>
    <tr><td class="paramname">success</td><td>true if I/O completed successfully or false if it failed; additional error information may be retrieved from bdev_io by calling <a class="el" href="bdev_8h.html#afe43254747db3cd072dfb596be3bbf2f" title="Get the status of bdev_io as an NVMe status code. ">spdk_bdev_io_get_nvme_status()</a> or <a class="el" href="bdev_8h.html#ac3c213b4317d5077197950253af1ac50" title="Get the status of bdev_io as a SCSI status code. ">spdk_bdev_io_get_scsi_status()</a>. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Callback argument specified when bdev_io was submitted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af5600670a9cb061bb5bd9ed4d8dd7046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5600670a9cb061bb5bd9ed4d8dd7046">&#9670;&nbsp;</a></span>spdk_bdev_claim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_bdev_claim </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_bdev_remove_cb_t&#160;</td>
          <td class="paramname"><em>remove_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>remove_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Claim ownership of a block device. </p>
<p>User applications and virtual blockdevs may use this to mediate access to bdevs.</p>
<p>When the ownership of the bdev is no longer needed, the user should call <a class="el" href="bdev_8h.html#ae080366bf0d3b59d0bb05f2b3e698dea" title="Release claim of ownership of a block device. ">spdk_bdev_unclaim()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to claim. </td></tr>
    <tr><td class="paramname">remove_cb</td><td>callback function for hot remove the device. </td></tr>
    <tr><td class="paramname">remove_ctx</td><td>param for hot removal callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the caller claimed the bdev, or false if it was already claimed by another user. </dd></dl>

</div>
</div>
<a id="a79093fc354725f29207cd9038ac4144a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79093fc354725f29207cd9038ac4144a">&#9670;&nbsp;</a></span>spdk_bdev_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_flush </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a flush request to the bdev on the given channel. </p>
<p>For devices with volatile caches, data is not guaranteed to be persistent until the completion of a flush request. Call <a class="el" href="bdev_8h.html#a93f6d6ce09da384501f09a49581caa37" title="Query whether block device has an enabled write cache. ">spdk_bdev_has_write_cache()</a> to check if the bdev has a volatile cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#a1b4015ff9aba44261f3b36cde064963a" title="Obtain an I/O channel for this block device. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset, in bytes, from the start of the block device. </td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a id="a536a365e14bc4f3ddf76b9340958ebd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a536a365e14bc4f3ddf76b9340958ebd8">&#9670;&nbsp;</a></span>spdk_bdev_free_io()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_free_io </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_io *&#160;</td>
          <td class="paramname"><em>bdev_io</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an I/O request. </p>
<p>This should be called after the callback for the I/O has been called and notifies the bdev layer that memory may now be released.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev_io</td><td>I/O request</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 on failure, 0 on success. </dd></dl>

</div>
</div>
<a id="a3ba8c5672c8226b9b63f44543518c527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba8c5672c8226b9b63f44543518c527">&#9670;&nbsp;</a></span>spdk_bdev_get_block_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_bdev_get_block_size </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get block device logical block size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of logical block for this bdev in bytes. </dd></dl>

</div>
</div>
<a id="ab4d238484b372a77ba130fbb70f83519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4d238484b372a77ba130fbb70f83519">&#9670;&nbsp;</a></span>spdk_bdev_get_buf_align()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t spdk_bdev_get_buf_align </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get minimum I/O buffer address alignment for a bdev. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Required alignment of I/O buffers in bytes. </dd></dl>

</div>
</div>
<a id="a1b4015ff9aba44261f3b36cde064963a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b4015ff9aba44261f3b36cde064963a">&#9670;&nbsp;</a></span>spdk_bdev_get_io_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_io_channel* spdk_bdev_get_io_channel </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain an I/O channel for this block device. </p>
<p>I/O channels are bound to threads, so the resulting I/O channel may only be used from the thread it was originally obtained from.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the I/O channel or NULL on failure. </dd></dl>

</div>
</div>
<a id="ab1ba28ba382edd1d792d51a054eb3aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ba28ba382edd1d792d51a054eb3aa2">&#9670;&nbsp;</a></span>spdk_bdev_get_io_stat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_get_io_stat </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__bdev__io__stat.html">spdk_bdev_io_stat</a> *&#160;</td>
          <td class="paramname"><em>stat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return I/O statistics for this channel. </p>
<p>After returning stats, zero out the current state of the statistics.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#a1b4015ff9aba44261f3b36cde064963a" title="Obtain an I/O channel for this block device. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">stat</td><td>The per-channel statistics. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a055368a3ce95cb597c99e9920dd025a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a055368a3ce95cb597c99e9920dd025a4">&#9670;&nbsp;</a></span>spdk_bdev_get_max_unmap_descriptors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_bdev_get_max_unmap_descriptors </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get maximum number of descriptors per unmap request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of unmap descriptors per request. </dd></dl>

</div>
</div>
<a id="ad97a853dcb945bf004817424b7aa28af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad97a853dcb945bf004817424b7aa28af">&#9670;&nbsp;</a></span>spdk_bdev_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* spdk_bdev_get_name </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get block device name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Name of bdev as a null-terminated string. </dd></dl>

</div>
</div>
<a id="a86568eca8f0b4d0dc9bc59c5138fc7a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86568eca8f0b4d0dc9bc59c5138fc7a5">&#9670;&nbsp;</a></span>spdk_bdev_get_num_blocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_bdev_get_num_blocks </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get size of block device in logical blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of bdev in logical blocks.</dd></dl>
<p>Logical blocks are numbered from 0 to spdk_bdev_get_num_blocks(bdev) - 1, inclusive. </p>

</div>
</div>
<a id="a1cb4d1f8822c30be8c5d9c5dc3e62483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb4d1f8822c30be8c5d9c5dc3e62483">&#9670;&nbsp;</a></span>spdk_bdev_get_product_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* spdk_bdev_get_product_name </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get block device product name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Product name of bdev as a null-terminated string. </dd></dl>

</div>
</div>
<a id="a93f6d6ce09da384501f09a49581caa37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f6d6ce09da384501f09a49581caa37">&#9670;&nbsp;</a></span>spdk_bdev_has_write_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_bdev_has_write_cache </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether block device has an enabled write cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if block device has a volatile write cache enabled.</dd></dl>
<p>If this function returns true, written data may not be persistent until a flush command is issued. </p>

</div>
</div>
<a id="aa05d8c0e82bfbcc209af1eb958230ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa05d8c0e82bfbcc209af1eb958230ede">&#9670;&nbsp;</a></span>spdk_bdev_io_get_iovec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_io_get_iovec </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_io *&#160;</td>
          <td class="paramname"><em>bdev_io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec **&#160;</td>
          <td class="paramname"><em>iovp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iovcntp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the iovec describing the data buffer of a bdev_io. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev_io</td><td>I/O to describe with iovec. </td></tr>
    <tr><td class="paramname">iovp</td><td>Pointer to be filled with iovec. </td></tr>
    <tr><td class="paramname">iovcntp</td><td>Pointer to be filled with number of iovec entries. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe43254747db3cd072dfb596be3bbf2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe43254747db3cd072dfb596be3bbf2f">&#9670;&nbsp;</a></span>spdk_bdev_io_get_nvme_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_io_get_nvme_status </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_bdev_io *&#160;</td>
          <td class="paramname"><em>bdev_io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the status of bdev_io as an NVMe status code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev_io</td><td>I/O to get the status from. </td></tr>
    <tr><td class="paramname">sct</td><td>Status Code Type return value, as defined by the NVMe specification. </td></tr>
    <tr><td class="paramname">sc</td><td>Status Code return value, as defined by the NVMe specification. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3c213b4317d5077197950253af1ac50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c213b4317d5077197950253af1ac50">&#9670;&nbsp;</a></span>spdk_bdev_io_get_scsi_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_io_get_scsi_status </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_bdev_io *&#160;</td>
          <td class="paramname"><em>bdev_io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>asc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ascq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the status of bdev_io as a SCSI status code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev_io</td><td>I/O to get the status from. </td></tr>
    <tr><td class="paramname">sc</td><td>SCSI Status Code. </td></tr>
    <tr><td class="paramname">sk</td><td>SCSI Sense Key. </td></tr>
    <tr><td class="paramname">asc</td><td>SCSI Additional Sense Code. </td></tr>
    <tr><td class="paramname">ascq</td><td>SCSI Additional Sense Code Qualifier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0ff477709a4931e98b10c2f39d2d9fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ff477709a4931e98b10c2f39d2d9fc">&#9670;&nbsp;</a></span>spdk_bdev_nvme_admin_passthru()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_nvme_admin_passthru </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit an NVMe Admin command to the bdev. </p>
<p>This passes directly through the block layer to the device. Support for NVMe passthru is optional, indicated by calling spdk_bdev_io_type_supported().</p>
<p>The SGL/PRP will be automated generated based on the given buffer, so that portion of the command may be left empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#a1b4015ff9aba44261f3b36cde064963a" title="Obtain an I/O channel for this block device. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">cmd</td><td>The raw NVMe command. Must be an admin command. </td></tr>
    <tr><td class="paramname">buf</td><td>Data buffer to written from. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes to transfer. buf must be greater than or equal to this size. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a id="a6073d0f21b837b1afc22859c1d067d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6073d0f21b837b1afc22859c1d067d77">&#9670;&nbsp;</a></span>spdk_bdev_nvme_io_passthru()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_nvme_io_passthru </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit an NVMe I/O command to the bdev. </p>
<p>This passes directly through the block layer to the device. Support for NVMe passthru is optional, indicated by calling spdk_bdev_io_type_supported().</p>
<p>The SGL/PRP will be automated generated based on the given buffer, so that portion of the command may be left empty. Also, the namespace id (nsid) will be populated automatically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#a1b4015ff9aba44261f3b36cde064963a" title="Obtain an I/O channel for this block device. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">cmd</td><td>The raw NVMe command. Must be in the NVM command set. </td></tr>
    <tr><td class="paramname">buf</td><td>Data buffer to written from. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes to transfer. buf must be greater than or equal to this size. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a id="a17931abec6a7169432d56b3b72ce604f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17931abec6a7169432d56b3b72ce604f">&#9670;&nbsp;</a></span>spdk_bdev_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_read </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a read request to the bdev on the given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#a1b4015ff9aba44261f3b36cde064963a" title="Obtain an I/O channel for this block device. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">buf</td><td>Data buffer to read into. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset, in bytes, from the start of the block device. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes to read. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a id="a39cf118897336906dfd286b3c91295ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39cf118897336906dfd286b3c91295ce">&#9670;&nbsp;</a></span>spdk_bdev_readv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_readv </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *&#160;</td>
          <td class="paramname"><em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovcnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a read request to the bdev on the given channel. </p>
<p>This differs from spdk_bdev_read by allowing the data buffer to be described in a scatter gather list. Some physical devices place memory alignment requirements on data and may not be able to directly transfer into the buffers provided. In this case, the request may fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#a1b4015ff9aba44261f3b36cde064963a" title="Obtain an I/O channel for this block device. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">iov</td><td>A scatter gather list of buffers to be read into. </td></tr>
    <tr><td class="paramname">iovcnt</td><td>The number of elements in iov. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset, in bytes, from the start of the block device. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes to read. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a id="a08b7c843568980d0f2e2245ee296ee4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b7c843568980d0f2e2245ee296ee4a">&#9670;&nbsp;</a></span>spdk_bdev_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_reset </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a reset request to the bdev on the given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#a1b4015ff9aba44261f3b36cde064963a" title="Obtain an I/O channel for this block device. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a id="ae080366bf0d3b59d0bb05f2b3e698dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae080366bf0d3b59d0bb05f2b3e698dea">&#9670;&nbsp;</a></span>spdk_bdev_unclaim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_unclaim </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release claim of ownership of a block device. </p>
<p>When a bdev reference acquired with <a class="el" href="bdev_8h.html#af5600670a9cb061bb5bd9ed4d8dd7046" title="Claim ownership of a block device. ">spdk_bdev_claim()</a> is no longer needed, the user should release the claim using <a class="el" href="bdev_8h.html#ae080366bf0d3b59d0bb05f2b3e698dea" title="Release claim of ownership of a block device. ">spdk_bdev_unclaim()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to release. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ae20739bcbd84bde357e89d96b5e5e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae20739bcbd84bde357e89d96b5e5e7">&#9670;&nbsp;</a></span>spdk_bdev_unmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_unmap </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__scsi__unmap__bdesc.html">spdk_scsi_unmap_bdesc</a> *&#160;</td>
          <td class="paramname"><em>unmap_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>bdesc_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit an unmap request to the block device. </p>
<p>Unmap is sometimes also called trim or deallocate. This notifies the device that the data in the blocks described is no longer valid. Reading blocks that have been unmapped results in indeterminate data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#a1b4015ff9aba44261f3b36cde064963a" title="Obtain an I/O channel for this block device. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">unmap_d</td><td>An array of unmap descriptors. </td></tr>
    <tr><td class="paramname">bdesc_count</td><td>The number of elements in unmap_d. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a id="a9dd2e65f126665954c23eff4477d4557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd2e65f126665954c23eff4477d4557">&#9670;&nbsp;</a></span>spdk_bdev_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_write </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a write request to the bdev on the given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#a1b4015ff9aba44261f3b36cde064963a" title="Obtain an I/O channel for this block device. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">buf</td><td>Data buffer to written from. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset, in bytes, from the start of the block device. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes to write. buf must be greater than or equal to this size. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a id="a22f12f278859dc4e0c6cdec33f9dcb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f12f278859dc4e0c6cdec33f9dcb24">&#9670;&nbsp;</a></span>spdk_bdev_writev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_writev </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *&#160;</td>
          <td class="paramname"><em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovcnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a write request to the bdev on the given channel. </p>
<p>This differs from spdk_bdev_write by allowing the data buffer to be described in a scatter gather list. Some physical devices place memory alignment requirements on data and may not be able to directly transfer out of the buffers provided. In this case, the request may fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#a1b4015ff9aba44261f3b36cde064963a" title="Obtain an I/O channel for this block device. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">iov</td><td>A scatter gather list of buffers to be written from. </td></tr>
    <tr><td class="paramname">iovcnt</td><td>The number of elements in iov. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset, in bytes, from the start of the block device. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes to read. buf must be greater than or equal to this size. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
</div><!-- contents -->
<footer>
  <div class="container text-center">
    <p class="copyright text-muted small">Copyright © Intel Corporation. All Rights Reserved.</p>
  </div>
</footer>
</div>
